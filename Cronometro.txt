
;*******************************************************************
;* This stationery serves as the framework for a user application. *
;* For a more comprehensive program that demonstrates the more     *
;* advanced functionality of this processor, please see the        *
;* demonstration applications, located in the examples             *
;* subdirectory of the "Freescale CodeWarrior for HC08" program    *
;* directory.                                                      *
;*******************************************************************

; Include derivative-specific definitions
; En el archivo " derivative,inc"  se referencia a " MC68HC908QY4.inc" que contiene
; todas las definiciones de los registros, puertos y tabla de vectores de interrupciones

            INCLUDE 'derivative.inc'

; export symbols
            XDEF _Startup, main
            ; we export both '_Startup' and 'main' as symbols. Either can
            ; be referenced in the linker .prm file or from C/C++ later on

            XREF __SEG_END_SSTACK   ; symbol defined by the linker for the end of the stack


; variable/data section
MY_ZEROPAGE: SECTION  SHORT         ; Insert here your data definitio

;#######################AQUI SE DEFINEN LAS VARIABLES######################
		
medio_seg           ds 1 ;variable aux para medir 1 interrupcion/seg
contador_seg	    ds 1 ;contador de segundos
contador_min 	    ds 1 ;contador de minutos
status		 		ds 1 ;define el estado del cronometro (0 apagado / 1 contando)
dot		 			ds 1 ;punto
puntero		 		ds 1 ;puntero para la tabla
aux 				ds 2 ;variable auxiliar para mostrar numeros en 7segmentos

;#######################AQUI SE DEFINEN LAS VARIABLES######################

;#################################STARTUP##################################

; code section
MyCode:     SECTION
main:
_Startup:

;Definir I/O en los Puertos

            LDHX 	#__SEG_END_SSTACK 	; initialize the stack pointer
            TXS				
            CLRX						; limpio registro indice
            CLI              			; habilito las interrupciones 
            LDA  	#$FF
            STA  	DDRB				; todos los bits del PuertoB como salidas
            LDA  	#%11100000			 
            STA  	DDRD				; asigno I/O del PuertoD

;Limpio todos los 7 segmentos            
           
           	JSR	  	apagar7s	
	   		
;Inicializo variables	
	   		
	   		CLR  	puntero				; limpio el puntero
			CLR  	aux					; limpio variable auxiliar
            ClR  	contador_seg		; limpio contador de segundos
            CLR  	contador_min    	; limpio contador de minutos
            CLR  	status 				; setea status en cero
            CLR  	medio_seg       	; setea medio_seg en cero

;Setear el timer (TIM)

			LDA  	#%00110000			; resetea y para el contador
			STA  	TSC					; guardo en TSC
			LDA  	#$96		
			STA  	TMODH
			LDA  	#$00
			STA  	TMODL				; seteo el numero desde el cual quiero que cuente para generar la interrupcion
			LDA  	#%01000110		    ; seteo que el timer divida por 64 su frecuencia y empiece a contar
			STA  	TSC					; guardo en TSC
		
;Muestra Iniciales
;"S"			
			LDA  	#%11101100			; cargo la inicial "S"
			STA  	PTB					; guardo en la salida PTB
			LDA  	#%00000000			; selecciono el display 4
			STA  	PTD
			JSR  	delay				; subrutina de delay para apreciar el display
;"G"			
			LDA  	#%11111100			; cargo la inicial "G"
			STA  	PTB					; guardo en la salida PTB
			LDA  	#%00100000			; selecciono el display 3
			STA  	PTD
			JSR  	delay				; subrutina de delay para apreciar el display
;"L"			
			LDA  	#%00111000			; cargo la inicial "L"
			STA  	PTB					; guardo en la salida PTB
			LDA  	#%01000000			; selecciono el display 2
			STA  	PTD
			JSR  	delay				; subrutina de delay para apreciar el display
;"J"			
			LDA  	#%10011110			; cargo la inicial "J"
			STA  	PTB					; guardo en la salida PTB
			LDA  	#%01100000			; selecciono el display 1
			STA  	PTD
			JSR  	delay				; subrutina de delay para apreciar el display
			
;Apaga los display
			
			JSR	 	apagar7s

;#################################STARTUP##################################					  				            

;################################MAINLOOP##################################

mainLoop: 				
			feed_watchdog
;Se chequea el estado de los switches	
		

;Chequeo el Pulsador 1 	
			
			LDA 	PTD					; cargo el PuertoD
			BIT		#%00000100			; se activo SW1?
			BEQ	    no_press1			; si fue pulsado activar AntiBounce sino continuar a SW2
			JSR 	delay				; rutina de anti-rebote para el SW1
			LDA 	PTD
			BIT 	#%00000100			; SW1 esta siendo pulsado realmente?
			BEQ	    no_press1			; si fue pulsado atiendo con Subrutina sino continua a SW2
			JSR 	pulsador1
no_press1
;Chequeo el Pulsador2 	
		
			LDA 	PTD					; cargo el PuertoD
			BIT		#%00001000			; se activo SW2?
			BEQ		no_press2			; si fue pulsado activar AntiBounce sino continuar con 7segmentos
			JSR 	delay				; rutina de anti-rebote para el SW1
			LDA 	PTD
			BIT		#%00001000			; SW2 esta siendo pulsado realmente?
			BEQ  	no_press2			; si fue pulsado atiendo con Subrutina sino continuar con 7segmentos
			JSR 	pulsador2
no_press2

;Se muestran en los 7segmentos los numeros de la cuenta

;Unidades Segundos			
			
			LDHX 	#tablaBaja			; tomo la 1ra pos. de la tabla (2 bytes)
			LDA  	contador_seg		; cargo contador segundos
			AND  	#$0F				; enmascaro el nibble BAJO
			STA  	puntero				; guardo en el puntero
			STHX 	aux					; guardo la 1ra pos. de la tabla en aux (2 bytes)
			LDA  	aux+1				; cargo parte baja de aux (1 byte)
			ADD  	puntero				; sumo puntero que contiene el numero a mostrar
			STA  	aux+1			
			LDA  	aux					; cargo parte alta de aux (1 byte)
			ADC  	#$00				; sumo SOLO el Carry en caso de existir
			STA  	aux
			LDHX 	aux					; cargo aux que contiene (1ra pos. de la tabla)+(puntero)
			LDA  	0,X					; obtengo el codigo para mostrar el numero 
			STA  	PTB					; guardo en la salida PTB
			LDA  	#%00000000			; selecciono el display 4
			STA  	PTD
			JSR  	delay				; subrutina de delay para apreciar el display
			
;Decenas Segundos
		
			LDHX 	#tablaBaja			; tomo la 1ra pos. de la tabla (2 bytes)
			LDA  	contador_seg		; cargo contador segundos
			AND  	#$F0		    	; enmascaro el nibble ALTO
			NSA 						; invierto nibble alto con bajo
			STA  	puntero				; guardo en el puntero
			STHX 	aux					; guardo la 1ra pos. de la tabla en aux (2 bytes)
			LDA  	aux+1				; cargo parte baja de aux (1 byte)
			ADD  	puntero				; sumo puntero que contiene el numero a mostrar
			STA  	aux+1			
			LDA  	aux					; cargo parte alta de aux (1 byte)
			ADC  	#$00				; sumo SOLO el Carry en caso de existir
			STA  	aux
			LDHX 	aux					; cargo aux que contiene (1ra pos. de la tabla)+(puntero)
			LDA  	0,X					; obtengo el codigo para mostrar el numero
			STA  	PTB					; guardo en la salida PTB
			LDA  	#%00100000			; selecciono el display 3
			STA  	PTD
			JSR  	delay				; subrutina de delay para apreciar el display
			
;Unidades Minutos
			
			LDHX 	#tablaBaja			; tomo la 1ra pos. de la tabla (2 bytes)
			LDA  	contador_min		; cargo contador segundos
			AND  	#$0F				; enmascaro el nibble BAJO
			STA  	puntero				; guardo en el puntero
			STHX 	aux					; guardo la 1ra pos. de la tabla en aux (2 bytes)
			LDA 	aux+1				; cargo parte baja de aux (1 byte)
			ADD  	puntero				; sumo puntero que contiene el numero a mostrar
			STA  	aux+1			
			LDA  	aux					; cargo parte alta de aux (1 byte)
			ADC  	#$00				; sumo SOLO el Carry en caso de existir
			STA  	aux
			LDHX 	aux					; cargo aux que contiene (1ra pos. de la tabla)+(puntero)
			LDA  	0,X					; obtengo el codigo para mostrar el numero 
			STA  	PTB					; guardo en la salida PTB
    	    LDA  	#%01000000			; selecciono el display 2
			STA  	PTD
			JSR  	delay				; subrutina de delay para apreciar el display
			
;Decenas Minutos
			
			LDHX 	#tablaBaja	   		; inicializo puntero en
			LDA  	contador_min		; cargo contador segundos
			AND  	#$F0		   		; enmascaro el nibble ALTO
			NSA 						; invierto nibble alto con bajo
			STA  	puntero				; guardo en el puntero
			STHX 	aux					; guardo la 1ra pos. de la tabla en aux (2 bytes)
			LDA  	aux+1				; cargo parte baja de aux (1 byte)
			ADD  	puntero				; sumo puntero que contiene el numero a mostrar
			STA  	aux+1			
			LDA  	aux					; cargo parte alta de aux (1 byte)
			ADC  	#$00				; sumo SOLO el Carry en caso de existir
			STA  	aux
			LDHX 	aux					; cargo aux que contiene (1ra pos. de la tabla)+(puntero)
			LDA  	0,X					; obtengo el codigo para mostrar el numero
			STA  	PTB					; guardo en la salida PTB
			LDA  	#%01100000			; selecciono el display 1
			STA  	PTD
			JSR  	delay				; subrutina de delay para apreciar el display	
		
;Vuelve a repetirse todo otra vez		
	  	   	
	  	   	JMP  	mainLoop	

;################################MAINLOOP##################################	

;########################INTERRUPCIONES Y SUBRUTINAS#######################		

;Timer Cristal (interrupcion cada 1/2 seg)
INT_TIMER	
			LDA  	TSC					; cargo el TSC
			BCLR 	7,TSC 				; limpia el bit 7 del TSC (TIMOverflow)
			LDA  	medio_seg			; cargo medio_seg
			CMPA 	#$01				; medio_seg = 1?
			BEQ  	temporizador		; branch si cero (paso 1 seg) a temporizador
			; sino
			ADD  	#$01				; sumo 1
			STA  	medio_seg			; guardo medio_seg
			RTI							; termina la atencion a interrupcion

;Cuento segundos		
temporizador	
			LDA  	status				; cargo status
			CMPA 	#$00 				; status = 0?
			BEQ  	al_loop				; si status = 0 no debe contar (vuelvo al loop) 
			; sino	
			LDA  	contador_seg		; cargo contador_seg
			CMPA 	#$59				; segundos = 59?
			BEQ  	cuenta_min			; si segundos = 59 debo contar 1 minuto
			; sino
			ADD  	#$01				; suma 1 segundo
			DAA							; ajuste decimal
			STA  	contador_seg		; guardo contador_seg
			CLR  	medio_seg			; reseteo medio_seg para el prox. segundo
			RTI
al_loop
			CLR  	medio_seg			; reseteo medio_seg para el prox. segundo
			RTI							; termina la atencion a interrupcion	
			
;Cuento	minutos		
cuenta_min
			CLR  	contador_seg		; limpio contador segundos
			LDA  	contador_min		; cargo contador_min
			CMPA 	#$59				; minutos = 59?
			BEQ  	reset				; si minutos = 59 se resetea la cuenta
			; sino
			ADD  	#$01				; suma 1 minuto
			DAA							; ajuste decimal
			STA  	contador_min		; guardo contador_min
			CLR  	medio_seg			; reseteo medio_seg para el prox. segundo
			RTI							; termina la atencion a interrupcion
							
;Reseteo en la hora
reset		
			CLR  	medio_seg							 
			CLR  	contador_min		; limpio contadores
			CLR  	status				; limpia status
			;aca parpadea				
			RTI							; termina la atencion a interrupcion

;Retardo para mostrar los numeros en display o Antibounce (~10mseg)	
delay	

   		 	LDHX 	#$2500   			; Cargar X con $2500 (3 ciclos)
DELAY_LOOP
 		 	NOP         				; 1 ciclo 
   		 	NOP         				; 1 ciclo 
   		 	NOP         				; 1 ciclo 
   		 	NOP         				; 1 ciclo 
   		 	DECX         				; 1 ciclo 
   		 	BNE  	DELAY_LOOP 			; Salta a DELAY_LOOP si X no es cero (3 ciclos)
  		 	RTS         				; Return from Subroutine (4 ciclos)	

;Subrutina del Pulsador 1 (1 Play / 0 Pausa)
pulsador1
			LDA  	status				; cargo el status
			COMA						; switchea entre 1 (play) / 0 (pausa) el status
			STA  	status
			RTS

;Subrutina del Pulsador 2 (Reset)
pulsador2	
			CLR  	status				; limpia status
			CLR  	medio_seg
			CLR  	contador_seg
			CLR  	contador_min		; limpio contadores
			RTS
			
;Apagar todos los 7 segmentos
apagar7s
			LDA  	#$00					
			STA  	PTB					; guardo en la salida PTB
			LDA  	#%00000000			; selecciono el display 4
			STA  	PTD					
			LDA  	#$00
			STA  	PTB					; guardo en la salida PTB
			LDA  	#%00100000			; selecciono el display 3
			STA  	PTD
			LDA  	#$00
			STA  	PTB					; guardo en la salida PTB
			LDA  	#%01000000			; selecciono el display 2
			STA  	PTD
			LDA  	#$00
			STA  	PTB					; guardo en la salida PTB
			LDA  	#%01100000			; selecciono el display 1
			STA 	PTD	
			RTS	
			
			BRA FIN						; salto incondicional a FIN
  		
;########################INTERRUPCIONES Y SUBRUTINAS#######################	

tablaBaja
		  	DC.B 	$BE	; 0
 		  	DC.B 	$06	; 1
		  	DC.B 	$DA	; 2
		  	DC.B 	$CE	; 3
		  	DC.B 	$66	; 4
		  	DC.B 	$EC	; 5
		  	DC.B 	$FC	; 6
		  	DC.B 	$86	; 7 	 
		  	DC.B 	$FE	; 8
		  	DC.B 	$EE	; 9	
FIN:
			RTI
;****************************************************************************** 
;*   Atencion de Interrupciones, no hacer nada por ahora
  
Vacio            
            RTI          ; retorna sin hacer nada

;*****************************************************************************

            org  	INT_ADC  		   ; a partir de $FFDE

       		dcw   	Vacio              ;FFDE+FFDF, (direccion de atencion de INT_ADC)
      		dcw   	Vacio              ;FFE0+FFE1, (direccion atencion de INT KBI)
      		dcw   	Vacio              ;FFE2+FFE3, (reservado 2, no usado)
        	dcw   	Vacio              ;FFE4+FFE5, (reservado 3, no usado)
        	dcw   	Vacio              ;FFE6+FFE7, (reservado 4, no usado)
        	dcw   	Vacio              ;FFE8+FFE9, (reservado 5, no usado)
        	dcw   	Vacio              ;FFEA+FFEB, (reservado 6, no usado)
        	dcw   	Vacio              ;FFEC+FFED, (reservado 7, no usado)
        	dcw   	Vacio              ;FFEE+FFEF, (reservado 8, no usado)
        	dcw   	Vacio              ;FFE0+FFE1, (reservado 9, no usado)
        	dcw   	INT_TIMER		   ;FFF2+FFF3, (direccion por TIMOvr) 
        	dcw   	Vacio              ;FFF4+FFF5, (direccion por TIM Channel 1) 
        	dcw   	Vacio              ;FFF6+FFF7, (direccion por TIM Channel 0) 
        	dcw   	Vacio              ;FFE8+FFE9, (reservado 13, no usado)
        	dcw   	Vacio              ;FFFA+FFFB, (direccion atencion por IRQ)
        	dcw   	Vacio              ;FFFC+FFFD, (direccion atencion por SWI)
;        	dcw   	main               ;FFFE+FFFF, (direccion programa,RESET)
; ya esta definida main, por eso se muestra la linea comentada
;*******************************************************************************